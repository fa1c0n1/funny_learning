!_TAG_FILE_SORTED	1	/0=unsorted, 1=sorted, 2=foldcase/
!_TAG_FILE_FORMAT	2	/extended format; --format=1 will not append ;" to lines/
!_TAG_PROGRAM_VERSION	5.9~svn20110310	//
LOCAL_MODULE	Android.mk	/^LOCAL_MODULE := bctest$/;"	m
LOCAL_MODULE	Android.mk	/^LOCAL_MODULE := servicemanager$/;"	m
LOCAL_MODULE_TAGS	Android.mk	/^LOCAL_MODULE_TAGS := optional$/;"	m
LOCAL_PATH	Android.mk	/^LOCAL_PATH:= $(call my-dir)$/;"	m
LOCAL_SHARED_LIBRARIES	Android.mk	/^LOCAL_SHARED_LIBRARIES := liblog libselinux$/;"	m
LOCAL_SHARED_LIBRARIES	Android.mk	/^LOCAL_SHARED_LIBRARIES := liblog$/;"	m
LOCAL_SRC_FILES	Android.mk	/^LOCAL_SRC_FILES := bctest.c binder.c$/;"	m
LOCAL_SRC_FILES	Android.mk	/^LOCAL_SRC_FILES := service_manager.c binder.c$/;"	m
svc_c_flags	Android.mk	/^svc_c_flags =	\\$/;"	m
!_TAG_PROGRAM_AUTHOR	Darren Hiebert	/dhiebert@users.sourceforge.net/
!_TAG_PROGRAM_NAME	Exuberant Ctags	//
BIO_F_IOERROR	binder.c	85;"	d	file:
BIO_F_MALLOCED	binder.c	86;"	d	file:
BIO_F_OVERFLOW	binder.c	84;"	d	file:
BIO_F_SHARED	binder.c	83;"	d	file:
LOG_TAG	binder.c	18;"	d	file:
MAX_BIO_SIZE	binder.c	14;"	d	file:
NAME	binder.c	60;"	d	file:
TRACE	binder.c	16;"	d	file:
_bio_get_obj	binder.c	/^static struct flat_binder_object *_bio_get_obj(struct binder_io *bio)$/;"	f	file:
binder_acquire	binder.c	/^void binder_acquire(struct binder_state *bs, uint32_t target)$/;"	f
binder_become_context_manager	binder.c	/^int binder_become_context_manager(struct binder_state *bs)$/;"	f
binder_call	binder.c	/^int binder_call(struct binder_state *bs,$/;"	f
binder_close	binder.c	/^void binder_close(struct binder_state *bs)$/;"	f
binder_done	binder.c	/^void binder_done(struct binder_state *bs,$/;"	f
binder_dump_txn	binder.c	/^void binder_dump_txn(struct binder_transaction_data *txn)$/;"	f
binder_dump_txn	binder.c	80;"	d	file:
binder_link_to_death	binder.c	/^void binder_link_to_death(struct binder_state *bs, uint32_t target, struct binder_death *death)$/;"	f
binder_loop	binder.c	/^void binder_loop(struct binder_state *bs, binder_handler func)$/;"	f
binder_open	binder.c	/^struct binder_state *binder_open(size_t mapsize)$/;"	f
binder_parse	binder.c	/^int binder_parse(struct binder_state *bs, struct binder_io *bio,$/;"	f
binder_release	binder.c	/^void binder_release(struct binder_state *bs, uint32_t target)$/;"	f
binder_send_reply	binder.c	/^void binder_send_reply(struct binder_state *bs,$/;"	f
binder_state	binder.c	/^struct binder_state$/;"	s	file:
binder_write	binder.c	/^int binder_write(struct binder_state *bs, void *data, size_t len)$/;"	f
bio_alloc	binder.c	/^static void *bio_alloc(struct binder_io *bio, size_t size)$/;"	f	file:
bio_alloc_obj	binder.c	/^static struct flat_binder_object *bio_alloc_obj(struct binder_io *bio)$/;"	f	file:
bio_get	binder.c	/^static void *bio_get(struct binder_io *bio, size_t size)$/;"	f	file:
bio_get_ref	binder.c	/^uint32_t bio_get_ref(struct binder_io *bio)$/;"	f
bio_get_string16	binder.c	/^uint16_t *bio_get_string16(struct binder_io *bio, size_t *sz)$/;"	f
bio_get_uint32	binder.c	/^uint32_t bio_get_uint32(struct binder_io *bio)$/;"	f
bio_init	binder.c	/^void bio_init(struct binder_io *bio, void *data,$/;"	f
bio_init_from_txn	binder.c	/^void bio_init_from_txn(struct binder_io *bio, struct binder_transaction_data *txn)$/;"	f
bio_put_obj	binder.c	/^void bio_put_obj(struct binder_io *bio, void *ptr)$/;"	f
bio_put_ref	binder.c	/^void bio_put_ref(struct binder_io *bio, uint32_t handle)$/;"	f
bio_put_string16	binder.c	/^void bio_put_string16(struct binder_io *bio, const uint16_t *str)$/;"	f
bio_put_string16_x	binder.c	/^void bio_put_string16_x(struct binder_io *bio, const char *_str)$/;"	f
bio_put_uint32	binder.c	/^void bio_put_uint32(struct binder_io *bio, uint32_t n)$/;"	f
cmd_name	binder.c	/^const char *cmd_name(uint32_t cmd)$/;"	f
fd	binder.c	/^    int fd;$/;"	m	struct:binder_state	file:
hexdump	binder.c	/^void hexdump(void *_data, size_t len)$/;"	f
hexdump	binder.c	79;"	d	file:
mapped	binder.c	/^    void *mapped;$/;"	m	struct:binder_state	file:
mapsize	binder.c	/^    size_t mapsize;$/;"	m	struct:binder_state	file:
BINDER_SERVICE_MANAGER	binder.h	31;"	d
PING_TRANSACTION	binder.h	/^    PING_TRANSACTION  = B_PACK_CHARS('_','P','N','G'),$/;"	e	enum:__anon1
SVC_MGR_ADD_SERVICE	binder.h	/^    SVC_MGR_ADD_SERVICE,$/;"	e	enum:__anon1
SVC_MGR_CHECK_SERVICE	binder.h	/^    SVC_MGR_CHECK_SERVICE,$/;"	e	enum:__anon1
SVC_MGR_GET_SERVICE	binder.h	/^    SVC_MGR_GET_SERVICE = 1,$/;"	e	enum:__anon1
SVC_MGR_LIST_SERVICES	binder.h	/^    SVC_MGR_LIST_SERVICES,$/;"	e	enum:__anon1
SVC_MGR_NAME	binder.h	33;"	d
_BINDER_H_	binder.h	5;"	d
binder_death	binder.h	/^struct binder_death {$/;"	s
binder_handler	binder.h	/^typedef int (*binder_handler)(struct binder_state *bs,$/;"	t
binder_io	binder.h	/^struct binder_io$/;"	s
data	binder.h	/^    char *data;            \/* pointer to read\/write from *\/$/;"	m	struct:binder_io
data0	binder.h	/^    char *data0;           \/* start of data buffer *\/$/;"	m	struct:binder_io
data_avail	binder.h	/^    size_t data_avail;     \/* bytes available in data buffer *\/$/;"	m	struct:binder_io
flags	binder.h	/^    uint32_t flags;$/;"	m	struct:binder_io
func	binder.h	/^    void (*func)(struct binder_state *bs, void *ptr);$/;"	m	struct:binder_death
offs	binder.h	/^    binder_size_t *offs;   \/* array of offsets *\/$/;"	m	struct:binder_io
offs0	binder.h	/^    binder_size_t *offs0;  \/* start of offsets buffer *\/$/;"	m	struct:binder_io
offs_avail	binder.h	/^    size_t offs_avail;     \/* entries available in offsets array *\/$/;"	m	struct:binder_io
ptr	binder.h	/^    void *ptr;$/;"	m	struct:binder_death
unused	binder.h	/^    uint32_t unused;$/;"	m	struct:binder_io
!_TAG_PROGRAM_URL	http://ctags.sourceforge.net	/official site/
LOG_TAG	service_manager.c	20;"	d	file:
allow_isolated	service_manager.c	/^    int allow_isolated;$/;"	m	struct:svcinfo	file:
audit_callback	service_manager.c	/^static int audit_callback(void *data, security_class_t cls, char *buf, size_t len)$/;"	f	file:
check_mac_perms	service_manager.c	/^static bool check_mac_perms(pid_t spid, const char *tctx, const char *perm, const char *name)$/;"	f	file:
check_mac_perms_from_getcon	service_manager.c	/^static bool check_mac_perms_from_getcon(pid_t spid, const char *perm)$/;"	f	file:
check_mac_perms_from_lookup	service_manager.c	/^static bool check_mac_perms_from_lookup(pid_t spid, const char *perm, const char *name)$/;"	f	file:
death	service_manager.c	/^    struct binder_death death;$/;"	m	struct:svcinfo	typeref:struct:svcinfo::binder_death	file:
do_add_service	service_manager.c	/^int do_add_service(struct binder_state *bs,$/;"	f
do_find_service	service_manager.c	/^uint32_t do_find_service(struct binder_state *bs, const uint16_t *s, size_t len, uid_t uid, pid_t spid)$/;"	f
find_svc	service_manager.c	/^struct svcinfo *find_svc(const uint16_t *s16, size_t len)$/;"	f
handle	service_manager.c	/^    uint32_t handle;$/;"	m	struct:svcinfo	file:
len	service_manager.c	/^    size_t len;$/;"	m	struct:svcinfo	file:
main	service_manager.c	/^int main(int argc, char **argv)$/;"	f
name	service_manager.c	/^    uint16_t name[0];$/;"	m	struct:svcinfo	file:
next	service_manager.c	/^    struct svcinfo *next;$/;"	m	struct:svcinfo	typeref:struct:svcinfo::svcinfo	file:
sehandle	service_manager.c	/^static struct selabel_handle* sehandle;$/;"	v	typeref:struct:selabel_handle	file:
selinux_enabled	service_manager.c	/^static int selinux_enabled;$/;"	v	file:
service_manager_context	service_manager.c	/^static char *service_manager_context;$/;"	v	file:
str16eq	service_manager.c	/^int str16eq(const uint16_t *a, const char *b)$/;"	f
str8	service_manager.c	/^const char *str8(const uint16_t *x, size_t x_len)$/;"	f
svc_can_find	service_manager.c	/^static int svc_can_find(const uint16_t *name, size_t name_len, pid_t spid)$/;"	f	file:
svc_can_list	service_manager.c	/^static int svc_can_list(pid_t spid)$/;"	f	file:
svc_can_register	service_manager.c	/^static int svc_can_register(const uint16_t *name, size_t name_len, pid_t spid)$/;"	f	file:
svcinfo	service_manager.c	/^struct svcinfo$/;"	s	file:
svcinfo_death	service_manager.c	/^void svcinfo_death(struct binder_state *bs, void *ptr)$/;"	f
svclist	service_manager.c	/^struct svcinfo *svclist = NULL;$/;"	v	typeref:struct:svcinfo
svcmgr_handle	service_manager.c	/^uint32_t svcmgr_handle;$/;"	v
svcmgr_handler	service_manager.c	/^int svcmgr_handler(struct binder_state *bs,$/;"	f
svcmgr_id	service_manager.c	/^uint16_t svcmgr_id[] = {$/;"	v
main	test_client.c	/^int main(int argc, char **argv)$/;"	f
svcmgr_lookup	test_client.c	/^uint32_t svcmgr_lookup(struct binder_state *bs, uint32_t target, const char *name)$/;"	f
svcmgr_publish	test_client.c	/^int svcmgr_publish(struct binder_state *bs, uint32_t target, const char *name, void *ptr)$/;"	f
token	test_client.c	/^unsigned token;$/;"	v
hello_service_handler	test_server.c	/^int hello_service_handler(struct binder_state *bs,$/;"	f
main	test_server.c	/^int main(int argc, char **argv)$/;"	f
sayhello	test_server.c	/^void sayhello(void)$/;"	f
sayhello_to	test_server.c	/^int sayhello_to(char *name)$/;"	f
svcmgr_lookup	test_server.c	/^uint32_t svcmgr_lookup(struct binder_state *bs, uint32_t target, const char *name)$/;"	f
svcmgr_publish	test_server.c	/^int svcmgr_publish(struct binder_state *bs, uint32_t target, const char *name, void *ptr)$/;"	f
token	test_server.c	/^unsigned token;$/;"	v
HELLO_SVR_CMD_SAYHELLO	test_server.h	4;"	d
HELLO_SVR_CMD_SAYHELLO_TO	test_server.h	5;"	d
_TEST_SERVER_H	test_server.h	2;"	d
